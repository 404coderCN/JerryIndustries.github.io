---
layout: post
title: Cricket synchronization with raspberry pi pico
image: 
  path: /assets/img/projects/cricket_top.jpg
description: >
  chirp chirp chirp ü¶ó
sitemap: false
hide_last_modified: true
---
# Cricket synchronization with raspberry pi pico
## Background
Synchronization is a fascinating phenomenon common to a lot of biological systems. One of the most intriguing one can be observed on snowy tree crickets. When you wonder around in the woods or take a night walk in Ithaca, you can always hear these little creatures chirp. Most of the times, our brains filter them out as white noises, but if you pay attention, you will notice they chirp in synchrony. That's already better than some of us who lacks the "music gene"! In addition to synchronization, snowy tree crickets change the frequency and speed of their chirps as a function of the ambient temperature. On the east coast of the US, you can estimate the temperature outside (in Fahrenheit) by adding 40 to the number of chirps that you count in 15 seconds, so forget about Apple weather, next time, ask a snowy tree cricket for the temperature! This fascinating relationship between cricket chirps and temperature has a name--<a href="https://en.wikipedia.org/wiki/Dolbear%27s_law">Dolbear's law</a>.

Now that we know a bit about crickets, let's see how we can simulate their very fascinating behaviors. To accomplish this goal, we'll separate the project into three steps: 
1. Synthesize cricket chirps
2. Detect other chirps 
3. Synchronization

Before we dive into the technical details, I want to first say a few words about the insights I gained from this project and how it changed the way I view things. For a long time, I thought the goal of Electrical engineering is to make cool intelligent products. Phones, computers, robots and drones; I took my classes thinking I'm getting myself closer to designing one of these on my own. Whenever I have the freedom to choose my own final project, I always think about building some kind of robot, as it feels like a direct derivative of all the cool things I learnt in ECE, and anything other than that feels not so related and lacks the excitement. One a level, I thought of ECE and cool technologies as the same thing. They are the reason we learn about this subject and they are the final products. This project reminds me that ECE is much more than that. It can be much more than just the "objective", because it could also be a tool that we use to learn about all the exiciting things around us. And this applies to not just ECE. Engineering, in the general sense, is exiciting because we have this extra tool and extra perspective we can use to learn about the fascinating phenomenon in nature and all other things that we're interested in. There is a great big world outside of engineering, go explore it with all the tools you have!

## Concepts

### Synthesize cricket chirps
Before anything happens, let there be crickets. How? You ask. Well, it's time to introduce our very first algorithm -- **Direct Digital Synthesis** (DDS). Long story short, Direct Digital Synthesis produces an analog waveform by performing digital-to-analog conversion on a time-varying digital signal. The algorithm takes advantage of the homomorphism between an accumulator variable and the phasor angle: that is, rotating the phasor resembles the act of incrementing a 32-bit accumulator variable. To be more specific, the algorithm first initialize a 32-bit variable called Accumulator, which stores information of a scaled version of the phase angle. A phasor angle of 0 degrees, therefore, corresponds to an accumulator value of 0, and a phasor angle of 360 degrees corresponds to an accumulator value of 2^32-1. Because the analog waveform is generated by sending new samples to the Digital Analog Converter (DAC) at the sampling frequency, Fùë†, we obtain the relationship between the sampling frequency and the output frequency ‚Äì the frequency of the chirp sounds that we wish to produce:  

<img src="{{ "/assets/img/projects/DDS_1.png" | prepend: site.baseurl | prepend: site.url}}" alt="jagged sine wave" />

Be aware of the values for Fùë† and Fout. The required accumulator increment amount can be calculated with the following formula: 

<img src="{{ "/assets/img/projects/DDS_2.png" | prepend: site.baseurl | prepend: site.url}}" alt="jagged sine wave" />

The accumulator variable is then used as an index to a sine Lookup Table, and the corresponding output signal magnitude is sent to the Digital to analog converter (DAC). The sine table itself has 256 entries. Hmm, wait a minute, didn't you say the accumulator has 2^32 different states? How is 256 enough? To answer this,we first have to know what less entries means i   n our case. Basically, the less entries that you have in your sine table, the more harmonic distortion you will hear in your generated tones. This is due to the fact that the DAC acts like a zeroth-order hold. If you send it a value, it retains that value until you send it a new one. So, smooth sine waves become the jagged approximations to sine waves shown below. 

<img src="{{ "/assets/img/projects/jagged_sine.png" | prepend: site.baseurl | prepend: site.url}}" alt="jagged sine wave" />

The fundamental frequency correspond to fft index 1, and the first error harmonic is approximately at the number of entries in the table (i.e. the sample frequency) minus 1. As the number of entries in the table increase, the first error harmonic moves away from rthe fundamental. Now, human ears can only hear sounds within the range 20Hz~20kHz, so as long as we can push the first error harmonic beyond 20kHz, we won't be able to tell the difference! Plus, the amplitude of the error harmonic will also decrease as the entries in the table increase. This way, we can save ourselves from creating a gigantic 2^32 element table! For the same reason,we only use the most significant 8-bits of the accumulator to index into the sine table. The remaining bits are used to remain fractional precision in determining when we need to output a different value to the DAC. Now, let's do some math. Our desired syllable frequency is 2300 Hz, and the DAC sampling frequency is 40 kHz, thus syllable is expected to be 17ms long, corresponding to 680 cycles. Similarly, the separation time between each syllable is approximately 2ms, corresponding to 80 audio cycles. The chirp repeat interval is approximately 260ms, corresponding to 10400 audio cycles. As the DAC sampling frequency is 40 kHz, it‚Äôs expected to receive 40000 values computed by DDS every second. While it‚Äôs possible to compute all the values before playing the chirp sound, such implementation takes up too much memory and requires long set-up time. To solve this problem, timer interrupt, which allows one to momentarily exit the loop() function at precisely timed intervals while executing the separate ISR function, is introduced into the program. Particularly, the ISR would be triggered every 1/40000 second, during which the DDS algorithm computes the analog signal amplitude and sends it to the DAC. 

Because cricket chirp‚Äôs volume ramps up and down in real life rather than maintaining a consistent loudness, amplitude modulation is applied. We defined an attack time and decay time, during which the signal amplitude smoothly ramps from 0 to its max amplitude, and vice versa. In achieving the amplitude modulation, we multiply the chirp frequency with the amplitude envelope function shown below. 

<img src="{{ "/assets/img/projects/envelope_function.png" | prepend: site.baseurl | prepend: site.url}}" alt="Amplitude envelope function" />

### Detect other chirps 
After synthesizing the cricket chirps, we begin our first stage in achieving synchronization: detecting other cricket chirps. Here, we used the Fast Fourier Transform (FFT) to decompose a sequence of signal values and converts them from time domain to frequency domain. To collect data for FFT calculation, the Analog Digital Converter (ADC) on RP2040 is configured to gather input signals at 10kHz and store those samples in the ADC FIFO. Once data is in the ADC FIFO, DMA channel 2 will automatically move the ADC sample from the FIFO to a byte array of 1024 elements. With the 1024-element array filled up, data would be copied to a local array at the same time as DMA channel 3 starts. All DMA channel 3 does is to write to the control registers of DMA channel 2 and restart channel 2. As a result, FFT calculation is applied to the collected sample values in determining the maximum frequency of input signal, while the next batch of samples is being gathered. 

### Synchronization
When we are able to detect other cricket chirps, we can begin manipulating our chirp synthesis to achieve synchronization. We used the idea of an **integrate-and-fire oscillator**. Like its name suggests, this model fires and resets an integrator to zero when it reaches a set threshold. Here, we used the function y=sqrt(t), which is monotonic and concave down. Within the system, all oscillators gradually rise towards the firing threshold; when a particular oscillator fires, all other oscillators are "pulled up" by an amount ùúñ. Since the same pull-up amount œµ corresponds to distinct time increment at different locations of the curve, populations of integrate-and-fire oscillators will eventually synchronize. 


## Implementation
To make sure that both cores of the RP2040 microcontroller are able to synthesize cricket chirps, 2 timer interrupts ‚Äì each associated with one core ‚Äì were set up so as to generate values output to DAC with the DDS algorithm. The ISR would be triggered every 1/40000 second. Two global variables ‚Äì count_1 and count_0 ‚Äì were, therefore, defined and served as counters of the times that ISR has been triggered. To start the playing of a sound, both counters are set to 0. The global variables ‚Äì STATE_1 and STATE_0 ‚Äì were defined to represent the chirp state of each core: STATE is set to 0 when the chirp syllable is being generated, 1 for pauses between syllables, or 2 for pauses between chirps. Because the chirp sound consists of 8 syllables, we also defined variables ‚Äì count_0s and count_1s ‚Äì to keep track of the number of syllables that have been played. With count_1s and count_0s, we were able to differentiate whether the core is at syllable pause or at chirp pause ‚Äì that‚Äôs whether the core is at STATE 1 or STATE 2. The Finite State Machine diagram for chirp synthesis is shown below.

<img src="{{ "/assets/img/projects/FSM.png" | prepend: site.baseurl | prepend: site.url}}" alt="FSM of chiro synthesis" />

Take Core 0 FSM as an example, count_0 increments by 1 each time the timer interrupt ‚Äì repeating_timer_callback_core_0 ‚Äì is triggered. DDS values are only calculated and sent to DAC through SPI communication at STATE 0 ‚Äì the Chirp State. At STATE 1 and 2, there is no calculation other than counter incrementment. At STATE 0, the FSM transits to STATE 2, if count_0 is bigger than Beep Duration and 8 syllables have been generated, i.e. count_0s is equal to 7. If less than 8 syllables have been generated, the FSM transits to STATE 1. STATE 1 would transit to STATE 0, if count_0 is bigger than Beep Repeat Interval. STATE 2 would transit to STATE 0, if count_0 is bigger than Chirp Interval. It‚Äôs worthy of noting that count_0 should be reset to 0 at each transition, and count_0s should be updated accordingly as well. 

To better test the chirp synchronization functionality, two buttons were added to the circuits. With each button pressed, the corresponding core pauses the process of chirping. In buttons implementation, we connect one end of the button to the ground and the other end to GPIO pins of the microcontroller. The internal resistance of the microcontroller is utilized as pull-up resistor to prevent unknown floating state. 

Based on the result of FFT calculation, the cores should be able to determine whether there are crickets other than themselves chirping. To implement the chirp detection, the ADC and DMA configuration was firstly set up within the main function. The input signal samples await to be gathered within the while loop on Core 0. Once 1024 samples have been gathered, the FFT computation would be performed and the maximum frequency of the input signal would be stored in the variable, max_frequency. A maximum frequency within the bandwidth of 2200 Hz and 2400 Hz indicates that a chirp sound is detected, because the chirp frequency is defined to be 2300 Hz. We utilized the global variable ‚Äì STATE_1 and STATE_2 ‚Äì in determining which core or neither is generating the chirping signal. Table 1 illustrates all possible conditions for chirp signal detection. Particularly, the variables ‚Äì pause_0 and pause_1 ‚Äì indicate whether core 1 or core 0 is pausing due to pressed buttons. For instance, if pause_0 is equal to 1, core 0 is in the pausing state.

It‚Äôs worth noting that one single chirping signal should not be detected multiple times. To prevent that from happening, a global variable ‚Äì last_time ‚Äì is defined and stores the last time a chirp sound is detected. With the function time_us_32(), the current time of computing max frequency each time is measured and compared with the value stored in last_time. If the difference is bigger than a chirp length, chirp detection is skipped. It‚Äôs worthy of noting that the function time_us_32() returns the timestamp value in a 32-bit value, invalidating the algorithm in 72 minutes.

<img src="{{ "/assets/img/projects/truth_table.png" | prepend: site.baseurl | prepend: site.url}}" alt="FSM of chiro synthesis" />

In implementing the cricket chirp synchronization algorithm, a LookUp Table, which maps the Core‚Äôs current counting value to its newly increment counter value, ‚Äã‚Äãis set up. At each time, a chirp is detected, the LookUp Table would be used to update the counter. For instance, if Core 1 detects Chirping ‚Äì  indicating that Core 0 just chirped ‚Äì count_1 should refer to the LookUp Table and update its value. The code below is used to generate the LookUp table. Note that a spin lock was wrapped around the chirp detection unit so that the counter update would not be interspersed by any timer interrupt. 


```C
int Lookup_Table[CHIRP_INTERVAL];
fix15 Lookup_Incr = int2fix15(10);

for(int ii = 0; ii < CHIRP_INTERVAL; i++)
{
  fix15 Y_Incr = multfix15((sqrtfix(int2fix15(ii)) + Lookup_Incr),(sqrtfix(int2fix15(ii)) + Lookup_Incr));
  Lookup_Table[ii] = fix2int15(Y_Incr);
}

```

## Testing

### In-lab testing
We mainly used three types of testing techniques in checking and debugging our implementations‚Äìlistening to the audio produced, observing waveform on an oscilloscope and checking display on a serial monitor. These three methods facilitate one another by testing at different levels of precision, which together contribute to a more holistic testing strategy. For most of the parts involving a sound being produced, we can check its basic validity by playing the audio through a speaker. In synthesizing the cricket chirp, we can immediately tell whether it sounds organic or not by hearing the actual audio output. A correct implementation of the sine table should be able to push the first error harmonic to some frequency that is inaudible to a human ear, thus making the sound authentic. Implementation of the two pause buttons is also tested by checking if only the corresponding speaker is chirping when one of the buttons is held down, and no sound is expected when both buttons are pressed. Releasing the button should resume chirping for either or both cores. We then test on the next level of precision by connecting the two outputs on the DAC to an oscilloscope and measure the syllable length, syllable repeat interval, and chirp repeat interval with the cursors, then compare the value against those provided. We also check if there are 8 syllables within a chirp by zooming in on the waveforms on the oscilloscope. The specific waveforms and values will be discussed in the documentation section. Testing on these two levels of precision allow us to verify our implementation on the chirp synthesis stage.

In testing for the chirp detection function, we used a combination of hearing and observing serial monitor output. We connect the speaker to the audio socket and set up an UART communication between pico and our computer at a baud rate of 115200. Connecting one side to RX and TX of channel 0 UART and ground, and the other side to our computer, we are able to monitor the output on PuTTY, a serial console on windows. Because our chirp detection is in service for the later synchronization function, we only want a core to detect chirps that are not produced by itself. As we hold down one of the pause buttons, only one of the speakers should chirp, and we expect to see a print statement saying the paused core detected a chirp. If both buttons are pressed and no chirping sound is produced by other media, we confirm no sound is heard from the speakers and nothing should be printed on the serial monitor. In the case where both cores are paused but a chirping sound is heard, we should see a print statement saying other chirp is detected. Lastly, if both cores are chirping, nothing should be printed. Refer to the truth table in the implementation section for the complete logic behind the expected outputs for each chirp detection scenario. 

Testing for the final synchronization performance is also rather straightforward. We connected to both the speaker and the oscilloscope and desynchronized chirping from the two cores by holding down one of the pause buttons for a short while. We then listen to the chirping to see if they gradually come together, as well as observing the oscilloscope to confirm waveforms from the two channels move to within one chirp length within one another. As an interesting side note, we also observed synchronization on the oscilloscope without connecting to a speaker. 

### Field test
Eager to find out if our cricket can fit in its community, our group conducted a field test in Ithaca to find out if our digital cricket can synchronize with actual crickets. We replaced the speaker with a headphone to make our circuit more portable. After taking some time to locate the chirping sound source, we were able to find a cricket on a branch in the bush. We placed the headphone close to the cricket to play the chirping sound. During the process, we had to increase the chirp interval as all other crickets are chirping at a much slower rate than ours. This may be due to the unique feature that snowy tree crickets change their chirping frequency as a function of the ambient temperature, and this is a chillier time of the year. Luckily, after some adjustments, we were able to observe a short period of synchronization with the target cricket. Below is a video showing the synchronization. We were hoping to achieve synchronization with more crickets, but the sound produced by the headphone is not loud enough and we weren‚Äôt able to get the microphone to be close enough to the crickets to detect all the chirps. We believe by improving some of the hardware setups and reducing disturbance from our flashlight and the noise nearby, we will be able to achieve better results.

[![Field test synchronize with cricket](https://img.youtube.com/vi/2JBTRZqpJ3w/0.jpg)](https://www.youtube.com/shorts/2JBTRZqpJ3w)
